#!/usr/bin/env ruby

# Builder script for Opal and WASM compilation
# This script handles the compilation of Ruby applications to JavaScript (via Opal)
# and WebAssembly (WASM), with options to skip either compilation step.

require 'fileutils'
require 'open-uri'

class BuilderScript
  # Constants for WASM URLs
  RUBY_WASM_URL = "https://github.com/ruby/ruby.wasm/releases/latest/download/ruby-3.4-wasm32-unknown-wasip1-full.tar.gz"
  RUBY_WASI_TGZ_URL = "https://github.com/ruby/ruby.wasm/releases/download/2.7.1/ruby-3.4-wasm-wasi-2.7.1.tgz"

  def initialize(args)
    # Parse command line options
    @production = args.include?("--production")
    @update_mode = args.include?("--update")
    @skip_opal = args.include?("--skip-opal")
    @skip_wasm = args.include?("--skip-wasm")

    # Initialize build paths
    @build_dir = "build"
    @opal_dir = "#{@build_dir}/opal"
    @wasm_dir = "#{@build_dir}/wasm"

    # Create necessary build directories
    create_build_directories
  end

  # Main execution method
  def run
    # Install dependencies if needed
    install_dependencies

    # Run Opal compilation unless skipped
    compile_opal unless @skip_opal

    # Run WASM compilation unless skipped
    compile_wasm unless @skip_wasm

    # Display usage instructions
    show_usage_instructions
  end

  private

  # Create the necessary build directories
  def create_build_directories
    FileUtils.mkdir_p(@opal_dir)
    FileUtils.mkdir_p(@wasm_dir)
  end

  # Install dependencies using Bundler
  def install_dependencies
    system("bundle install") unless File.exist?("Gemfile.lock")

    if @update_mode
      puts "Forcing update of all gems via bundler..."
      system("bundle update")
    else
      puts "Gem update skipped (option --update not used)."
    end
  end

  # Compile the Ruby application with Opal
  def compile_opal
    puts "\n== Compiling with Opal =="

    # Download or update opal.min.js
    process_opal_js

    # Compile the Ruby kernel with Opal
    compile_opal_additional_files([:opal_init, :kernel,  :infos])

    # Prepare app directory
    copy_app_directory

    # Compile the application with Opal
    compile_opal_application
  end

  # Process opal.min.js (download or update)
  def process_opal_js
    opal_min_js_path = "#{@opal_dir}/opal.min.js"

    # Delete existing file if update mode is enabled
    if @update_mode && File.exist?(opal_min_js_path)
      puts "Option --update enabled, deleting existing file #{opal_min_js_path}..."
      File.delete(opal_min_js_path)
    end

  end

  # Compile the Ruby kernel with Opal
  def compile_opal_additional_files(files_to_compile)
    if @production
      debug=''
    else
      debug='--enable-source-location '
    end
    files_to_compile.each_with_index do |file, index|
      puts "Compiling Ruby #{file} with Opal..."
      if index == 0
        opal_compile_kernel = "cat  sources/#{file}.rb | bundle exec opal -r opal-parser --compile #{debug} - > #{@opal_dir}/#{file}.js"
      else
        opal_compile_kernel = "cat  sources/#{file}.rb | bundle exec opal  --no-opal  --compile  #{debug} - > #{@opal_dir}/#{file}.js"

      end
      system(opal_compile_kernel)
    end

  end

  # Copy app directory to build
  def copy_app_directory
    build_app_dir = "#{@build_dir}/app"
    FileUtils.mkdir_p(build_app_dir) unless Dir.exist?(build_app_dir)
    FileUtils.cp_r(Dir.glob("app/*"), build_app_dir)
  end

  # Compile the Ruby application with Opal
  def compile_opal_application
    puts "Compiling Ruby application with Opal..."

    # Récupérer le chemin du fichier source
    source_file = "#{@build_dir}/app/index.rb"

    # Définir le chemin du fichier temporaire
    # temp_file = "#{@build_dir}/app/index_temp.rb"

    # Lire le contenu du fichier source
    # content = File.read(source_file)

    # Remplacer require_relative par require
    # modified_content = content.gsub("require_relative", "require")

    # Écrire le contenu modifié dans le fichier temporaire
    # File.write(temp_file, content)

    # puts "Created temporary file with modified requires: #{temp_file}"

    # Compiler avec Opal en utilisant le fichier temporaire
    if @production
      debug=''
    else
      debug='--enable-source-location '
    end

    opal_compile_app = "cat #{source_file} | bundle exec opal --no-opal --compile #{debug} - > #{@opal_dir}/index.js"
    system(opal_compile_app)

    if $?.exitstatus == 0
      puts "Opal compilation successful! #{@opal_dir}/index.js created."
    else
      abort("Error during Opal compilation.")
    end
  end

  # Compile the Ruby application with WASM
  def compile_wasm
    puts "\n== Compiling with Ruby WASM =="

    # Download or update Ruby WASM
    process_ruby_wasm

    # Download or update Ruby WASI TGZ
    process_ruby_wasi_tgz

    # Compile the application to WASM
    compile_app_to_wasm

    # Modify the JavaScript files generated by WASM compilation
    modify_wasm_js_files
  end

  # Process Ruby WASM (download or update)
  def process_ruby_wasm
    ruby_wasm_dest = "#{@wasm_dir}/ruby.wasm"

    # Delete existing file if update mode is enabled
    if @update_mode && File.exist?(ruby_wasm_dest)
      puts "Option --update enabled, deleting existing file #{ruby_wasm_dest}..."
      File.delete(ruby_wasm_dest)
    end

    # Download Ruby WASM if it doesn't exist
    unless File.exist?(ruby_wasm_dest)
      wasm_archive = "#{@wasm_dir}/ruby-3.4-wasm32-unknown-wasip1-full.tar.gz"
      download_and_extract_wasm(RUBY_WASM_URL, wasm_archive, ruby_wasm_dest)
    else
      puts "Ruby WASM file already exists, skipping download."
    end
  end

  # Download and extract WASM archive
  def download_and_extract_wasm(url, archive_path, dest_path)
    puts "Downloading Ruby WASM..."
    FileUtils.mkdir_p(File.dirname(archive_path))
    download_file(url, archive_path)

    puts "Extracting #{archive_path}..."
    system("tar xfz #{archive_path} -C #{@wasm_dir}")

    FileUtils.mkdir_p(File.dirname(dest_path))
    FileUtils.mv("#{@wasm_dir}/ruby-3.4-wasm32-unknown-wasip1-full/usr/local/bin/ruby", dest_path)
    puts "Ruby WASM downloaded and moved to #{dest_path}"
  end

  # Process Ruby WASI TGZ (download or update)
  def process_ruby_wasi_tgz
    wasi_tgz = "#{@wasm_dir}/ruby-3.4-wasm-wasi-2.7.1.tgz"

    # Delete existing file if update mode is enabled
    if @update_mode && File.exist?(wasi_tgz)
      puts "Option --update enabled, deleting existing file #{wasi_tgz}..."
      File.delete(wasi_tgz)
    end

    # Download Ruby WASI TGZ if it doesn't exist
    unless File.exist?(wasi_tgz)
      download_and_extract_wasi_tgz(RUBY_WASI_TGZ_URL, wasi_tgz)
    else
      puts "ruby-3.4-wasm-wasi-2.7.1.tgz already exists, skipping download."
    end
  end

  # Download and extract WASI TGZ
  def download_and_extract_wasi_tgz(url, tgz_path)
    puts "Downloading ruby-3.4-wasm-wasi-2.7.1.tgz..."
    FileUtils.mkdir_p(File.dirname(tgz_path))
    download_file(url, tgz_path)

    puts "Extracting #{tgz_path}..."
    system("tar xfz #{tgz_path} -C #{@wasm_dir}")
    puts "ruby-3.4-wasm-wasi-2.7.1.tgz downloaded and extracted in the #{@wasm_dir} directory."
  end

  def compile_app_to_wasm
    puts "Compiling Ruby runtime to WebAssembly..."
    output_path = "#{@wasm_dir}/ruby_runtime.wasm"

    wasm_compile_cmd = "bundle exec rbwasm pack #{@wasm_dir}/ruby.wasm " +
      "--dir ./#{@wasm_dir}/ruby-3.4-wasm32-unknown-wasip1-full/usr::/usr " +
      "-o #{output_path}"

    puts "Executing: #{wasm_compile_cmd}"
    system(wasm_compile_cmd)

    if $?.exitstatus == 0
      puts "Ruby runtime successfully compiled to #{output_path}"
      return true
    else
      abort("Error during Ruby runtime WASM compilation.")
    end
  end

  # Modify the JavaScript files generated by WASM compilation
  def modify_wasm_js_files
    package_dist_dir = "#{@wasm_dir}/package/dist"
    iife_js_file_path = "#{package_dist_dir}/browser.script.iife.js"
    umd_js_file_path = "#{package_dist_dir}/browser.script.umd.js"

    # Make sure the package directory structure exists
    FileUtils.mkdir_p(File.dirname(iife_js_file_path))
    FileUtils.mkdir_p(File.dirname(umd_js_file_path))

    # Modify IIFE JavaScript file
    modify_js_file(
      iife_js_file_path,
      /const response = fetch\(`https:\/\/cdn\.jsdelivr\.net\/npm\/\$\{pkg\.name\}@\$\{pkg\.version\}\/dist\/ruby\+stdlib\.wasm`\);/,
      'const response = fetch(`./wasm/package/dist/ruby+stdlib.wasm`);'
    )

    # Modify UMD JavaScript file
    modify_js_file(
      umd_js_file_path,
      /const response = fetch\(`https:\/\/cdn\.jsdelivr\.net\/npm\/\$\{pkg\.name\}@\$\{pkg\.version\}\/dist\/ruby\+stdlib\.wasm`\);/,
      'const response = fetch(`./wasm/package/dist/ruby+stdlib.wasm`);'
    )
  end

  # Modify a JavaScript file with the given pattern and replacement
  def modify_js_file(file_path, pattern, replacement)
    if File.exist?(file_path)
      puts "Modifying JavaScript file #{file_path}..."
      content = File.read(file_path)
      new_content = content.gsub(pattern, replacement)
      File.write(file_path, new_content)
      puts "JavaScript file #{file_path} modified successfully!"
    else
      puts "Warning: JavaScript file #{file_path} not found. Check if WASM compilation generated the expected files."
    end
  end

  # Display usage instructions
  def show_usage_instructions
    puts "\n== Usage Instructions =="
    puts "To use the Opal version: open #{@build_dir}/index_opal.html in your browser."
    puts "To use the WASM version: open #{@build_dir}/index_wasm.html in your browser."
  end

  # Helper method to download a file from a URL
  def download_file(url, destination)
    URI.open(url) do |remote|
      File.open(destination, "wb") { |file| file.write(remote.read) }
    end
  end
end

# Run the script with command line arguments
if __FILE__ == $0
  builder = BuilderScript.new(ARGV)
  builder.run
end